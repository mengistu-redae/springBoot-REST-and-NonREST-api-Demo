/*
 * we need to write all the CRUD and other DB operations in this DAO layer.
 * But, since Spring JPA implements the common DB operations, we only need to extend use them here. 
 * 
 * we can also define our own methods (DB operations) here if we need some other 
 * complex or customized DB queries that are not present in the JpaRepository.
 * Example: findByAddress, findByIdGreaterThan, findByNameSorted ...
 * Note: their body implementation and the needed SQL query will be 
 * 		 generated by Spring Boot if we adhere spring JPA method naming standards
 * 
 * But, in the custom defined methods, we need to follow a Spring JPA method naming standard:
 * 	- "findBy + FieldName" , where field name is a field in the model class. 
 * 	  So that the spring JPA will help us to auto generate SQL query for us OR
 *  - any method name but with our own SQL like(JPQL) query provided above the 
 *    method with @Query annotation
 *    
*/


/*
 * Spring Data JPA provides an extra layer of abstraction on top of 
 * an existing JPA provider like Hibernate. The "derived query from method signature" feature!
 * 
 * Spring Data JPA generates DB queries by looking at the corresponding method names. Because,
 * it's simple to derive what the query should be just by looking at 
 * the corresponding method name in our code.
 * 
 * And for simple and most common queries, the method signatures are already availed by 
 * the Spring JPA itself. But, if we didn't find a method as we want, we are allowed to 
 * write the signature of the our own methods in this JPA repository class. Then Spring JPA will 
 * help us the remaining tasks like generating query (by looking at the name of the method name) 
 * and implementing the method body.
 * 
 * Therefore, there is a method naming convention by Spring JPA repository.
 * Thus, the rules for Derived Query Methods in Spring Data JPA Repositories is as following:
 * 
 * 		 --------------------
 * #1 - Structure of Derived Query Methods in Spring
 * 		 --------------------
 * Derived method names have two main parts separated by the first "By" keyword.
 * 	~ The first part is the introducer --- which could be: find, read, query, count, get, delete, save ...
 * 		We can also use Distinct, IgnoreCase, AllIgnoreCase, First, or Top to remove duplicates or 
 * 		limit our result set
 * 		Eg. List<User> findByName(String name)
 * 			List<User> findTop3ByAge()
 * 			List<User> findDistinctByEmail(String email);
 * 			List<User> findDistinctPeopleByNameOrEmail(String name, String email);
 * 			List<User> findByNameIgnoreCase(String name);
 * 			List<User> findByNameOrEmailAllIgnoreCase(String name, String email);
 * 			List<User> findByNameContainingOrderByNameDesc(String name);

 * 	~ The second part is the criteria --- such as ByName ... 
 * 		The criteria part contains the entity-specific condition expressions of the query.
 * 		We can use the condition keywords along with the entity's property(field) names.
 * 		We can also concatenate the expressions with And and Or,
 * 
 * Collection<User> findAllActiveUsers();
 * 
 * 		 --------------------
 * #2 - Queries that do not need any Condition Keywords
 * 		 --------------------
 * To retrieve all entries in a DB table, we use "All" keyword in the method name 
 * combined with the entity name.
 * 	~ Eg.
 * 		Collection<User> findAllUsers();
 * 		Collection<User> findAllUsersSorted();
 * 		Collection<User> findAllUsersOrderedByIdAsc();
 * 		Collection<User> findAllUsersOrderedByIdDesc();
 * 
 * 		 --------------------
 * #3 - Equality Condition Keywords
 * 		 --------------------
 * Exact equality is one of the most-used conditions in queries. We have several 
 * options to express equality (=) or IS operators in the query.
 * Also, we can use Distinct, IgnoreCase, AllIgnoreCase, First, or Top to remove 
 * duplicates or limit our result set.
 * 
 * 	~ append the property name without any keyword for an exact match condition OR
 * 	~ add "Is" or "Equals" for readability 
 * 	~ add "Not" or "IsNot" when we need to express inequality 
 * 	~ add "IsNull" or "IsNotNull" keyword to add IS NULL criteria to the query
 * 	~ add "True" and "False" keywords to add equality conditions for boolean types
 * 
 * 	~ Note:- the following key words DO NOT require a method argument:
 * 			 IsNull, IsNotNull, True, and False 
 * 	~ Note:- when we pass a null value for an equality condition, Spring interprets the 
 * 	  		 query as IS NULL in the generated SQL.
 * 	~ Eg.
 * 		List<User> findByName(String name);
 * 		List<User> findByNameIs(String name);
 * 		List<User> findByNameEquals(String name);
 * 		List<User> findByNameEqualsIgnoreCase(String name);
 * 		List<User> findByNameIsNot(String name);
 * 		List<User> findByNameIsNull();
 * 		List<User> findByNameIsNotNull();
 * 		List<User> findByActiveTrue();
 * 		List<User> findByActiveFalse();
 * 
 * 		 --------------------
 * 	#4 - Similarity Condition Keywords
 * 		 --------------------
 * When we need to query the results with a pattern of a property, we have a few options.
 *	~ use "StartingWith" keyword to find names that start with a given value, which is equivalent to "WHERE name LIKE 'value%'".
 *	~ use "EndingWith" keyword to find names that end with a given value
 *	~ use "Containing" keyword to to find names containing a given value, which is equivalent to WHERE name LIKE '%infix%':
 *	~ use "Like" or "NotLike" keywords to find names with our own custom string pattern
 *
 *	~ Note:- the three conditions "StartingWith, EndingWith, and Containing" are called 
 *			 predefined pattern expressions. So, we don't need to add % operator inside the 
 *			 argument when these methods are called. But in case of "Like" keyword,  we 
 *			 need it while we call the method.
 *	~ Note:- let's suppose we need to fetch the users whose names 
 *			 start with an a, contain b and end with c. Then, we use our own pattern using "Like" keyword.
 *
 *	~ Eg.
 * 		List<User> findByNameStartingWith(String prefix);
 * 		List<User> findByNameEndingWith(String suffix);
 * 		List<User> findByNameContaining(String infix);
 * 		List<User> findByNameLike(String likePattern);
 * 		List<User> findByNameNotLike(String likePattern);
 * 		//while we call the "findByNameLike" method, we provide the pattern as following:
 * 		String likePattern = "a%b%c";
 * 		userRepository.findByNameLike(likePattern);
 * 		userRepository.findByNameNotLike(likePattern);
 * 		
 * 		 --------------------
 * #5 - Comparison Condition Keywords
 * 		 --------------------	
 * To compare the records with the given value, we can use keywords like:
 * 	~ "LessThan" or "LessThanEqual"  --- find users who are < or <= a given age
 * 	~ "GreaterThan" or "GreaterThanEqual" --- find users who are > or >= a given age
 * 	~ "Between" --- find users who are between two ages
 * 	~ "Before" and "After" --- for time values i.e. users' birthDates, to find users 
 * 	  who were born before or after a given date. 
 * 
 * 	~ Eg. 
 * 		List<User> findByAgeLessThan(Integer age);
 * 		List<User> findByAgeLessThanEqual(Integer age);
 * 		List<User> findByAgeGreaterThan(Integer age);
 * 		List<User> findByAgeGreaterThanEqual(Integer age);
 * 		List<User> findByAgeBetween(Integer startAge, Integer endAge);
 * 		List<User> findByAgeIn(Collection<Integer> ages);
 * 		List<User> findByBirthDateAfter(ZonedDateTime birthDate);
 * 		List<User> findByBirthDateBefore(ZonedDateTime birthDate);
 * 		
 * 
 * 		 --------------------	
 * #6 - Multiple Condition Expressions
 * 		 --------------------	
 * We can combine as many expressions as we need by using And and Or keywords.
 * The precedence order is And then Or, just like Java.
 * But for complex queries with more combinations of expressions, use the @Query annotation instead.
 * 
 *	~ Eg.
 * 		List<User> findByNameOrEmail(String name, String email);
 * 		List<User> findByNameOrBirthDate(String name, ZonedDateTime birthDate);
 * 		List<User> findByNameOrBirthDateAndActive(String name, ZonedDateTime birthDate, Boolean active);
 * 
 * 		 --------------------
 * #7 - Sorting the Results
 * 		 --------------------
 * We can ask that the users be sorted alphabetically by their name using "OrderBy" or "Sorted" keywords
 * "Asc" or "Desc" keywords can be used to tell the ordering style, but default is Ascending 
 * 
 * If we need dynamic ordering, we can add a Sort parameter to your query method. 
 * This is one of the special parameters supported by Spring Data JPA. 
 * Sort triggers the generation of an "ORDER BY" clause.
 * 
 * 	~ Eg.
 * 		List<User> findByNameOrderByName(String name);
 * 		List<User> findByNameOrderByNameAsc(String name);
 * 		List<User> findByNameOrderByNameDesc(String name);
 * 		List<User> findByNameContainingOrderByNameDesc(String name);
 * 		List<User> findByNameContaining(String name, Sort sort);
 *		//To call the above method, you need to create a Sort object as in the below when to call the method.
 * 		// sort users in ascending order
 * 		List<User> users = userRepository.findByNameContaining("john", Sort.by("name").descending());
 * 		// sort users in descending order
 * 		List<User> users = userRepository.findByNameContaining("john", Sort.by("name").descending());
 * 		// multiple sort parameters
 * 		List<User> users = userRepository.findByNameContaining("john", Sort.by("name", "age").descending());
 *  
 *  
 * 		 --------------------
 * #8 - Limiting Derived Query Results
 * 		 --------------------
 * The results of derived query methods can be limited by using the First or Top keywords.
 * An optional numeric value can be added to Top or First to specify the maximum number of 
 * results to be returned. If the number is not provided, a result size of 1 is used.
 * 
 * Also, we can use Distinct, IgnoreCase, AllIgnoreCase, First, or Top to remove 
 * duplicates or limit our result set.
 * 	~ Eg.
 * 		User findFirstByOrderByName();
 * 		User findTopByOrderByAgeDesc();
 * 		List<User> findFirst5ByEmail(String email);
 * 		List<User> findDistinctTop3ByAgeLessThan(int age);
 *  
 * 
 * 		 --------------------
 * #9 - Paginate Derived Query Results
 * 		 --------------------	
 * Spring Data JPA provides another special parameter "Pageable" to apply 
 * pagination to query results. We just need to add this special parameter to our 
 * query method definition and change the return type to Page<User>. Spring Data JPA will 
 * automatically create an appropriate paging query.
 * 
 * ~ Eg.
 * 		Page<User> findByActive(boolean active, Pageable pageable);
 * 
 * We just define the page number we want to retrieve and how many records should 
 * be per page when we call the method.
 * 	~ Eg. 
 * 		Pageable pageable = PageRequest.of(0, 10);
 * 		Page<User> userPage = userRepository.findByActive(true, pageable)
 * 
 * We can even add dynamic sorting to derived query through the Pageable instance.
 * 	~ Eg.
 * 		Pageable pageable = PageRequest.of(0, 10, Sort.by("name").descending());
 * 		Page<User> userPage = userRepository.findByActive(true, pageable);
 * 
 * 
 * 		 --------------------
 * #10 - Derived Delete Queries
 * 		 --------------------
 * Spring Data JPA also supports derived delete queries.
 * 	~ Eg.
 * 		// delete all users by name
 * 		void deleteByName(String name);
 * 
 * 		// delete all active or inactive users
 * 		void deleteAllByActive(boolean active);
 * 
 */

